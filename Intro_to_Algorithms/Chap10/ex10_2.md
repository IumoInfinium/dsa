# Chapter 10.1 Stacks And Queues

## 10.1-1 $\star$

> Can you implement the dynamic-set operation INSERT on a singly linked list in $\text{O(1)}$ time? How about $\text{DELETE}$?
### Solution

```(cpp)
void insertFirst(){
    if(start == NULL){
        create_node();
        start = tmp;
        last = tmp;
        tmp = NULL;
    }
    else{
        create_node();
        tmp->next = start;
        start = tmp;
        //tmp = NULL;
    }
}
```

```(cpp)
void deleteMid(){
    if(start == NULL) printf("\nNo linked list exists..\n");
    }
    else{
        int num;
        printf("Select the place to delete from");
        scanf("%d",&num);
        if(num>n) printf("Linked LISt is not that big..");
        else if (num==n){
            printf("\ndeleting the last element from the list...\n");
            deleteLast();
        }
        else{
            node *p;
            tmp = start;
            for(int i=0;i<num-1;i++){
                p= tmp;
                tmp=tmp->next;
            }
            p->next = tmp->next;
            free(tmp); 
            tmp = NULL;
            n--;
        }
    }
}
```

## 10.1-2 $\star$

> Implement a stack using a singly linked list L. The operations PUSH and POP should still take O.1/ time.

### Solution

```(cpp)
void push(Node *HEAD,int x){
    Node* tmp = create_node();
    tmp->data = x;
    if(HEAD == NULL){
        HEAD->next = tmp;
    }
    else{
        tmp->next = HEAD->next;
        HEAD->next = tmp;
    }
    return;
}
```

```(cpp)
void pop(Node *HEAD){
    Node *tmp = HEAD->next;
    if(tmp == NULL) return;
    else{
        HEAD->next=tmp->next;
        free(tmp);
        return;
    }
}
```

```(cpp)
int peek(Node *HEAD){
    Node *tmp = HEAD->next;
    if(tmp==NULL) return -1;
    return tmp->data; 
}
```

## 10.1-3 $\star$

> Implement a queue by a singly linked list L. The operations ENQUEUE and DEQUEUE should still take O.1/ time.

```
void enqueue(Senti *S,int data){
    Node* tmp = create_node();
    tmp->data = data;
    if(S->next == NULL){
        S->next = tmp;
        S->prev = tmp;
    }
    else{
        S->prev->next = tmp;
        S->prev=tmp;
    }
    return;
}

void dequeue(Senti *S){
    if(S->next == NULL) return;
    Node* tmp = S->next;
    S->next = tmp->next;
    free(tmp);
    tmp = NULL;
}

int peek(Senti *S){
    if(S == nullptr) return INT_MIN;
    return S->next->data;
}
```

## 10.1-4 $\star$

> Rewrite $\text{ENQUEUE}$ and $\text{DEQUEUE}$ to detect underflow and overflow of a queue.

```(cpp)
void ListSearch(List L, int ele){
    Pointer x = L.nil.next;     // first element in Linked list
    L.nil.data = ele;           // set Sentinenl with given data
    while(x.data != ele){
        x = x->next;
    }
    return x;
}
```

## 10.1-5 $\star$

> mplement the dictionary operations INSERT, DELETE, and SEARCH using singly linked, circular lists. What are the running times of your procedures?

### Solution

```(cpp)
void insert_node(Node *senti,int ele){
    Node *new_node = create_node();
    new_node->key = ele; 
    new_node->next = senti->next;
    senti->next=new_node;
}

Node* search(Node *senti,int ele){
    Node *tmp = senti;
    if(tmp->next == senti){
        cout << "phew\n";
        return NULL;
    }
    while(tmp->next!= senti && tmp->next->key != ele){
        tmp=tmp->next;
    }
    if(tmp->next == senti){
        cout <<"Element not found " <<ele << "\n";
        return NULL;
    }
    cout << "Element found " << tmp->next->key << "\n";
    return tmp;
}

void delete_node(Node *senti,int ele){
    Node *prev = search(senti,ele);
    if(!prev) return;
    Node *tmp = prev->next;
    prev->next = tmp->next;
    free(tmp);
    tmp=NULL;
}
```

## 10.1-6 $\star$

> The dynamic-set operation UNION takes two disjoint sets S1 and S2 as input, and it returns a set $\text{S=(S1 U S2)}$ consisting of all the elements of S1 and S2. The sets S1 and S2 are usually destroyed by the operation. Show how to support UNION in $\text{O(1)}$ time using a suitable list data structure
### Solution

Queue can be implemented using 2 stacks.
Let the two stacks be $A$ and $B$.

- When the element is inserted into imaginary queue(actually a stack), it pushs all the elements from current stack to another stack in reverse order.

- $\text{Enqueue}$: $\Theta(1)$.
- $\text{Dequeue}$: worst $O(n)$,

$\text{ENQUEUE}$ pushes elements on $B$. $\text{DEQUEUE}$ pops elements from $A$. If $A$ is empty, the contents of $B$ are transfered to $A$ by popping them out of $B$ and pushing them to $A$. That way they appear in reverse order and are popped in the original.

## 10.1-7

> Show how to implement a stack using two queues. Analyze the running time of the stack operations.

### Solution

Let `q1` & `q2` be 2 queues. 
Two ways to implement stack with queues are 

1. Push operation costly
2. Pop operation costly

#### For first, the algorithm will be

Follow the below steps to implement the push(s, x) operation: 
- Enqueue x to q2.
- One by one dequeue everything from q1 and enqueue to q2.
- Swap the queues of q1 and q2.

Follow the below steps to implement the pop(s) operation: 

- Dequeue an item from q1 and return it.

#### For second case , the algorithm will be

Follow the below steps to implement the push(s, x) operation: 
- Enqueue x to q1 (assuming the size of q1 is unlimited).

Follow the below steps to implement the pop(s) operation: 

- One by one dequeue everything except the last element from q1 and enqueue to q2.
- Dequeue the last item of q1, the dequeued item is the result, store it.
- Swap the names of q1 and q2
- Return the item stored in step 2.
